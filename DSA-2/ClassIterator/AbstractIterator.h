#pragma once

/// Абстрактный класс итератора (интерфейс)
/// Тип T задаёт тип элементов, по которым будет проходить итератор.
template <typename T>
class AbstractIterator {
public:
    /**
     *  Виртуальный деструктор.
     *
     * Объявлен как `virtual` и `= default`, чтобы:
     * 1. Гарантировать корректное удаление объектов через указатель на базовый класс.
     *    Пример:
     *        AbstractIterator<int>* it = new ListIterator<int>(...);
     *        delete it; // безопасно, вызовется деструктор производного класса
     *
     * 2. Не требовать пользовательской реализации — `= default` просит компилятор
     *    сгенерировать "пустой" деструктор автоматически.
     */
    virtual ~AbstractIterator() = default;


    /**
     *  Переход к следующему элементу последовательности (префиксный инкремент).
     *
     * Должен изменить внутреннее состояние итератора так, чтобы он указывал на следующий элемент.
     *
     * @return Ссылка на сам итератор 
     *
     */
    virtual AbstractIterator& operator++() = 0;


    /**
     * Разыменование итератора — доступ к текущему элементу.
     *
     * Возвращает ссылку на элемент, на который указывает итератор.
     *
     * @return Ссылка на элемент типа T, который можно читать или изменять.
     *
     */
    virtual T& operator*() const = 0;


    /**
     *  Проверка, что два итератора указывают на разные элементы.
     *
     * @param other Другой итератор для сравнения.
     * @return true, если итераторы указывают на разные позиции;
     *         false, если итераторы равны (указывают на один и тот же элемент или конец).
     */
    virtual bool operator!=(const AbstractIterator& other) const = 0;
};
